{"version":3,"sources":["../src/constants.ts","../src/context.ts","../node_modules/.pnpm/@antfu+utils@0.5.0/node_modules/@antfu/utils/dist/index.mjs","../src/options.ts","../src/files.ts","../src/utils.ts","../src/stringify.ts","../src/resolvers/react.ts","../src/resolvers/vue.ts","../src/resolvers/solid.ts","../src/customBlock.ts","../src/index.ts"],"sourcesContent":["export const MODULE_IDS = [\n  '~pages',\n  '~react-pages',\n  '~solid-pages',\n  'pages-generated',\n  'virtual:generated-pages',\n  'virtual:generated-pages-react',\n]\n\nexport const MODULE_ID_VIRTUAL = '/@vite-plugin-pages/generated-pages'\nexport const ROUTE_BLOCK_ID_VIRTUAL = '/@vite-plugin-pages/route-block'\n\nexport const routeBlockQueryRE = /\\?vue&type=route/\n\nexport const dynamicRouteRE = /^\\[(.+)\\]$/\nexport const cacheAllRouteRE = /^\\[\\.{3}(.*)\\]$/\nexport const replaceDynamicRouteRE = /^\\[(?:\\.{3})?(.*)\\]$/\n\nexport const nuxtDynamicRouteRE = /^_(.*)$/\nexport const nuxtCacheAllRouteRE = /^_$/\n\nexport const countSlashRE = /\\//g\n\nexport const pathToNameRE = [\n  /[_.\\-\\\\/]/g,\n  /[[:\\]()]/g,\n]\n\nexport const replaceIndexRE = /\\/?index$/\n","import { extname, join, resolve } from 'path'\nimport deepEqual from 'deep-equal'\nimport { slash, toArray } from '@antfu/utils'\nimport colors from 'picocolors'\nimport { resolveOptions } from './options'\nimport { getPageFiles } from './files'\nimport { debug, invalidatePagesModule, isTarget } from './utils'\nimport { resolveReactRoutes } from './resolvers/react'\nimport { resolveVueRoutes } from './resolvers/vue'\nimport { resolveSolidRoutes } from './resolvers/solid'\nimport { getRouteBlock } from './customBlock'\n\nimport type { FSWatcher } from 'fs'\nimport type { Logger, ViteDevServer } from 'vite'\nimport type { CustomBlock, PageOptions, ResolvedOptions, UserOptions } from './types'\n\nexport interface PageRoute {\n  path: string\n  route: string\n}\n\nexport class PageContext {\n  private _server: ViteDevServer | undefined\n  private _pageRouteMap = new Map<string, PageRoute>()\n  private _customBlockMap: Map<string, CustomBlock> = new Map()\n\n  rawOptions: UserOptions\n  root: string\n  options: ResolvedOptions\n  logger?: Logger\n\n  constructor(userOptions: UserOptions, viteRoot: string = process.cwd()) {\n    this.rawOptions = userOptions\n    this.root = slash(viteRoot)\n    debug.env('root', this.root)\n    this.options = resolveOptions(userOptions, this.root)\n    debug.options(this.options)\n  }\n\n  setLogger(logger: Logger) {\n    this.logger = logger\n  }\n\n  setupViteServer(server: ViteDevServer) {\n    if (this._server === server)\n      return\n\n    this._server = server\n    this.setupWatcher(server.watcher)\n  }\n\n  setupWatcher(watcher: FSWatcher) {\n    watcher\n      .on('unlink', (path) => {\n        path = slash(path)\n        if (!isTarget(path, this.options))\n          return\n        this.removePage(path)\n        this.onUpdate()\n      })\n    watcher\n      .on('add', async(path) => {\n        path = slash(path)\n        if (!isTarget(path, this.options))\n          return\n        const page = this.options.dirs.find(i => path.startsWith(slash(resolve(this.root, i.dir))))!\n        await this.addPage(path, page)\n        this.onUpdate()\n      })\n\n    watcher\n      .on('change', async(path) => {\n        path = slash(path)\n        if (!isTarget(path, this.options))\n          return\n        const page = this._pageRouteMap.get(path)\n        if (page)\n          this.checkCustomBlockChange(path)\n      })\n  }\n\n  async addPage(path: string | string[], pageDir: PageOptions) {\n    debug.pages('add', path)\n    for (const p of toArray(path)) {\n      const pageDirPath = slash(resolve(this.root, pageDir.dir))\n      const route = slash(join(pageDir.baseRoute, p.replace(`${pageDirPath}/`, '').replace(extname(p), '')))\n      this._pageRouteMap.set(p, {\n        path: p,\n        route,\n      })\n      await this.checkCustomBlockChange(p)\n    }\n  }\n\n  removePage(path: string | string[]) {\n    debug.pages('remove', path)\n    toArray(path).forEach((p) => {\n      this._pageRouteMap.delete(p)\n      this._customBlockMap.delete(p)\n    })\n  }\n\n  async checkCustomBlockChange(path: string) {\n    if (this.options.resolver !== 'vue')\n      return\n\n    const exitsCustomBlock = this._customBlockMap.get(path)\n    let customBlock: CustomBlock | undefined\n    try {\n      customBlock = await getRouteBlock(path, this.options)\n    } catch (error: any) {\n      // eslint-disable-next-line no-console\n      this.logger?.error(colors.red(`[vite-plugin-pages] ${error.message}`))\n      return\n    }\n    if (!exitsCustomBlock && !customBlock)\n      return\n\n    if (!customBlock) {\n      this._customBlockMap.delete(path)\n      debug.routeBlock('%s deleted', path)\n      return\n    }\n    if (!exitsCustomBlock || !deepEqual(exitsCustomBlock, customBlock)) {\n      debug.routeBlock('%s old: %O', path, exitsCustomBlock)\n      debug.routeBlock('%s new: %O', path, customBlock)\n      this._customBlockMap.set(path, customBlock)\n      this.onUpdate()\n    }\n  }\n\n  onUpdate() {\n    if (!this._server)\n      return\n\n    invalidatePagesModule(this._server)\n    debug.hmr('Reload generated pages.')\n    this._server.ws.send({\n      type: 'full-reload',\n    })\n  }\n\n  async resolveRoutes() {\n    if (this.options.resolver === 'vue')\n      return await resolveVueRoutes(this)\n    if (this.options.resolver === 'react')\n      return await resolveReactRoutes(this)\n    if (this.options.resolver === 'solid')\n      return await resolveSolidRoutes(this)\n  }\n\n  async searchGlob() {\n    const pageDirFiles = this.options.dirs.map((page) => {\n      const pagesDirPath = slash(resolve(this.options.root, page.dir))\n      const files = getPageFiles(pagesDirPath, this.options)\n      debug.search(page.dir, files)\n      return {\n        ...page,\n        files: files.map(file => slash(file)),\n      }\n    })\n\n    for (const page of pageDirFiles)\n      await this.addPage(page.files, page)\n\n    debug.cache(this.pageRouteMap)\n    debug.cache(this.customBlockMap)\n  }\n\n  get debug() {\n    return debug\n  }\n\n  get pageRouteMap() {\n    return this._pageRouteMap\n  }\n\n  get customBlockMap() {\n    return this._customBlockMap\n  }\n}\n","function clamp(n, min, max) {\n  return Math.min(max, Math.max(min, n));\n}\nfunction sum(...args) {\n  return flattenArrayable(args).reduce((a, b) => a + b, 0);\n}\n\nfunction toArray(array) {\n  array = array || [];\n  if (Array.isArray(array))\n    return array;\n  return [array];\n}\nfunction flattenArrayable(array) {\n  return toArray(array).flat(1);\n}\nfunction mergeArrayable(...args) {\n  return args.flatMap((i) => toArray(i));\n}\nfunction partition(array, ...filters) {\n  const result = new Array(filters.length + 1).fill(null).map(() => []);\n  array.forEach((e, idx, arr) => {\n    let i = 0;\n    for (const filter of filters) {\n      if (filter(e, idx, arr)) {\n        result[i].push(e);\n        return;\n      }\n      i += 1;\n    }\n    result[i].push(e);\n  });\n  return result;\n}\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction last(array) {\n  return at(array, -1);\n}\nfunction remove(array, value) {\n  if (!array)\n    return false;\n  const index = array.indexOf(value);\n  if (index >= 0) {\n    array.splice(index, 1);\n    return true;\n  }\n  return false;\n}\nfunction at(array, index) {\n  const len = array.length;\n  if (!len)\n    return void 0;\n  if (index < 0)\n    index += len;\n  return array[index];\n}\nfunction range(...args) {\n  let start, stop, step;\n  if (args.length === 1) {\n    start = 0;\n    step = 1;\n    [stop] = args;\n  } else {\n    [start, stop, step = 1] = args;\n  }\n  const arr = [];\n  let current = start;\n  while (current < stop) {\n    arr.push(current);\n    current += step || 1;\n  }\n  return arr;\n}\nfunction move(arr, from, to) {\n  arr.splice(to, 0, arr.splice(from, 1)[0]);\n  return arr;\n}\nfunction clampArrayRange(n, arr) {\n  return clamp(n, 0, arr.length - 1);\n}\n\nconst assert = (condition, message) => {\n  if (!condition)\n    throw new Error(message);\n};\nconst toString = (v) => Object.prototype.toString.call(v);\nconst noop = () => {\n};\n\nfunction notNullish(v) {\n  return v != null;\n}\nfunction noNull(v) {\n  return v !== null;\n}\nfunction notUndefined(v) {\n  return v !== void 0;\n}\nfunction isTruthy(v) {\n  return Boolean(v);\n}\n\nconst isDef = (val) => typeof val !== \"undefined\";\nconst isBoolean = (val) => typeof val === \"boolean\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isNumber = (val) => typeof val === \"number\";\nconst isString = (val) => typeof val === \"string\";\nconst isObject = (val) => toString(val) === \"[object Object]\";\nconst isWindow = (val) => typeof window !== \"undefined\" && toString(val) === \"[object Window]\";\nconst isBrowser = typeof window !== \"undefined\";\n\nfunction slash(str) {\n  return str.replace(/\\\\/g, \"/\");\n}\nfunction ensurePrefix(prefix, str) {\n  if (!str.startsWith(prefix))\n    return prefix + str;\n  return str;\n}\nfunction ensureSuffix(suffix, str) {\n  if (!str.endsWith(suffix))\n    return str + suffix;\n  return str;\n}\nfunction template(str, ...args) {\n  return str.replace(/{(\\d+)}/g, (match, key) => {\n    const index = Number(key);\n    if (Number.isNaN(index))\n      return match;\n    return args[index];\n  });\n}\n\nconst timestamp = () => +Date.now();\n\nfunction batchInvoke(functions) {\n  functions.forEach((fn) => fn && fn());\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction tap(value, callback) {\n  callback(value);\n  return value;\n}\n\nfunction objectMap(obj, fn) {\n  return Object.fromEntries(Object.entries(obj).map(([k, v]) => fn(k, v)).filter(notNullish));\n}\nfunction isKeyOf(obj, k) {\n  return k in obj;\n}\nfunction objectKeys(obj) {\n  return Object.keys(obj);\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction deepMerge(target, ...sources) {\n  if (!sources.length)\n    return target;\n  const source = sources.shift();\n  if (source === void 0)\n    return target;\n  if (isMergableObject(target) && isMergableObject(source)) {\n    objectKeys(source).forEach((key) => {\n      if (isMergableObject(source[key])) {\n        if (!target[key])\n          target[key] = {};\n        deepMerge(target[key], source[key]);\n      } else {\n        target[key] = source[key];\n      }\n    });\n  }\n  return deepMerge(target, ...sources);\n}\nfunction isMergableObject(item) {\n  return isObject(item) && !Array.isArray(item);\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || !obj[k] === void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction clearUndefined(obj) {\n  Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {});\n  return obj;\n}\nfunction hasOwnProperty(obj, v) {\n  if (obj == null)\n    return false;\n  return Object.prototype.hasOwnProperty.call(obj, v);\n}\n\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction sleep(ms, callback) {\n  return new Promise((resolve) => setTimeout(async () => {\n    await (callback == null ? void 0 : callback());\n    resolve();\n  }, ms));\n}\nfunction createPromiseLock() {\n  const locks = [];\n  return {\n    async run(fn) {\n      const p = fn();\n      locks.push(p);\n      try {\n        return await p;\n      } finally {\n        remove(locks, p);\n      }\n    },\n    async wait() {\n      await Promise.allSettled(locks);\n    },\n    isWaiting() {\n      return Boolean(locks.length);\n    },\n    clear() {\n      locks.length = 0;\n    }\n  };\n}\n\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset).\n * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function}  A new, throttled, function.\n */\nfunction throttle (delay, noTrailing, callback, debounceMode) {\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n\n  function cancel() {\n    clearExistingTimeout();\n    cancelled = true;\n  } // `noTrailing` defaults to falsy.\n\n\n  if (typeof noTrailing !== 'boolean') {\n    debounceMode = callback;\n    callback = noTrailing;\n    noTrailing = undefined;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n\n  function wrapper() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n\n    function clear() {\n      timeoutID = undefined;\n    }\n\n    if (debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`.\n       */\n      exec();\n    }\n\n    clearExistingTimeout();\n\n    if (debounceMode === undefined && elapsed > delay) {\n      /*\n       * In throttle mode, if `delay` time has been exceeded, execute\n       * `callback`.\n       */\n      exec();\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\n\n/* eslint-disable no-undefined */\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                  to `callback` when the debounced-function is executed.\n *\n * @returns {Function} A new, debounced function.\n */\n\nfunction debounce (delay, atBegin, callback) {\n  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);\n}\n\n/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nclass Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\t\treturn current.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n\nfunction pLimit(concurrency) {\n\tif (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.size > 0) {\n\t\t\tqueue.dequeue()();\n\t\t}\n\t};\n\n\tconst run = async (fn, resolve, args) => {\n\t\tactiveCount++;\n\n\t\tconst result = (async () => fn(...args))();\n\n\t\tresolve(result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\tnext();\n\t};\n\n\tconst enqueue = (fn, resolve, args) => {\n\t\tqueue.enqueue(run.bind(undefined, fn, resolve, args));\n\n\t\t(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// when the run function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve();\n\n\t\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\t\tqueue.dequeue()();\n\t\t\t}\n\t\t})();\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => {\n\t\tenqueue(fn, resolve, args);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount,\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size,\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.clear();\n\t\t\t},\n\t\t},\n\t});\n\n\treturn generator;\n}\n\nconst VOID = Symbol(\"p-void\");\nclass PInstance extends Promise {\n  constructor(items = [], options) {\n    super(() => {\n    });\n    this.items = items;\n    this.options = options;\n    this.promises = /* @__PURE__ */ new Set();\n  }\n  get promise() {\n    var _a;\n    let batch;\n    const items = [...Array.from(this.items), ...Array.from(this.promises)];\n    if ((_a = this.options) == null ? void 0 : _a.concurrency) {\n      const limit = pLimit(this.options.concurrency);\n      batch = Promise.all(items.map((p2) => limit(() => p2)));\n    } else {\n      batch = Promise.all(items);\n    }\n    return batch.then((l) => l.filter((i) => i !== VOID));\n  }\n  add(...args) {\n    args.forEach((i) => {\n      this.promises.add(i);\n    });\n  }\n  map(fn) {\n    return new PInstance(Array.from(this.items).map(async (i, idx) => {\n      const v = await i;\n      if (v === VOID)\n        return VOID;\n      return fn(v, idx);\n    }), this.options);\n  }\n  filter(fn) {\n    return new PInstance(Array.from(this.items).map(async (i, idx) => {\n      const v = await i;\n      const r = await fn(v, idx);\n      if (!r)\n        return VOID;\n      return v;\n    }), this.options);\n  }\n  forEach(fn) {\n    return this.map(fn).then();\n  }\n  reduce(fn, initialValue) {\n    return this.promise.then((array) => array.reduce(fn, initialValue));\n  }\n  clear() {\n    this.promises.clear();\n  }\n  then(fn) {\n    const p2 = this.promise;\n    if (fn)\n      return p2.then(fn);\n    else\n      return p2;\n  }\n  catch(fn) {\n    return this.promise.catch(fn);\n  }\n  finally(fn) {\n    return this.promise.finally(fn);\n  }\n}\nfunction p(items, options) {\n  return new PInstance(items, options);\n}\n\nexport { assert, at, batchInvoke, clamp, clampArrayRange, clearUndefined, createPromiseLock, createSingletonPromise, debounce, deepMerge, ensurePrefix, ensureSuffix, flattenArrayable, hasOwnProperty, invoke, isBoolean, isBrowser, isDef, isFunction, isKeyOf, isNumber, isObject, isString, isTruthy, isWindow, last, mergeArrayable, move, noNull, noop, notNullish, notUndefined, objectEntries, objectKeys, objectMap, objectPick, p, partition, range, remove, slash, sleep, sum, tap, template, throttle, timestamp, toArray, toString, uniq };\n","import { resolve } from 'path'\nimport { slash, toArray } from '@antfu/utils'\nimport { getPageDirs } from './files'\n\nimport type { ImportModeResolver, ResolvedOptions, UserOptions } from './types'\n\nfunction resolvePageDirs(dirs: UserOptions['dirs'], root: string, exclude: string[]) {\n  dirs = toArray(dirs)\n  return dirs.flatMap((dir) => {\n    const option = typeof dir === 'string'\n      ? { dir, baseRoute: '' }\n      : dir\n\n    option.dir = slash(resolve(root, option.dir)).replace(`${root}/`, '')\n    option.baseRoute = option.baseRoute.replace(/^\\//, '').replace(/\\/$/, '')\n\n    return getPageDirs(option, root, exclude)\n  })\n}\n\nexport const syncIndexResolver: ImportModeResolver = (filepath, options) => {\n  for (const page of options.dirs) {\n    if (page.baseRoute === '' && filepath.startsWith(`/${page.dir}/index`))\n      return 'sync'\n  }\n  return 'async'\n}\n\nconst getExtensions = (resolver: ResolvedOptions['resolver']) => {\n  switch (resolver) {\n  case 'vue':\n    return ['vue', 'ts', 'js']\n  case 'react':\n  case 'solid':\n    return ['tsx', 'jsx', 'ts', 'js']\n  default:\n    throw new Error(`Unsupported resolver: ${resolver}`)\n  }\n}\n\nexport function resolveOptions(userOptions: UserOptions, viteRoot?: string): ResolvedOptions {\n  const {\n    dirs = userOptions.pagesDir || ['src/pages'],\n    routeBlockLang = 'json5',\n    exclude = [],\n    caseSensitive = false,\n    resolver = 'vue',\n    syncIndex = true,\n    extendRoute,\n    onRoutesGenerated,\n    onClientGenerated,\n  } = userOptions\n\n  const root = viteRoot || slash(process.cwd())\n\n  const importMode = userOptions.importMode || (syncIndex ? syncIndexResolver : 'async')\n\n  const extensions = userOptions.extensions || getExtensions(resolver)\n\n  const extensionsRE = new RegExp(`\\\\.(${extensions.join('|')})$`)\n\n  const resolvedDirs = resolvePageDirs(dirs, root, exclude)\n\n  const routeStyle = userOptions.nuxtStyle ? 'nuxt' : userOptions.routeStyle || 'next'\n\n  const resolvedOptions: ResolvedOptions = {\n    dirs: resolvedDirs,\n    routeStyle,\n    routeBlockLang,\n    root,\n    extensions,\n    importMode,\n    exclude,\n    caseSensitive,\n    resolver,\n    extensionsRE,\n    extendRoute,\n    onRoutesGenerated,\n    onClientGenerated,\n  }\n\n  return resolvedOptions\n}\n","import { join } from 'path'\nimport { slash } from '@antfu/utils'\nimport fg from 'fast-glob'\nimport { extsToGlob } from './utils'\n\nimport type { PageOptions, ResolvedOptions } from './types'\n\nfunction getIgnore(exclude: string[]) {\n  return ['node_modules', '.git', '**/__*__/**', ...exclude]\n}\n\n/**\n * Resolves the page dirs for its for its given globs\n */\nexport function getPageDirs(PageOptions: PageOptions, root: string, exclude: string[]): PageOptions[] {\n  const dirs = fg.sync(slash(PageOptions.dir), {\n    ignore: getIgnore(exclude),\n    onlyDirectories: true,\n    dot: true,\n    unique: true,\n    cwd: root,\n  })\n\n  const pageDirs = dirs.map(dir => ({\n    ...PageOptions,\n    dir,\n  }))\n\n  return pageDirs\n}\n\n/**\n * Resolves the files that are valid pages for the given context.\n */\nexport function getPageFiles(path: string, options: ResolvedOptions): string[] {\n  const {\n    exclude,\n    extensions,\n  } = options\n\n  const ext = extsToGlob(extensions)\n\n  const files = fg.sync(slash(join(path, `**/*.${ext}`)), {\n    ignore: getIgnore(exclude),\n    onlyFiles: true,\n  })\n\n  return files\n}\n","import { resolve, win32 } from 'path'\nimport Debug from 'debug'\nimport { slash } from '@antfu/utils'\nimport { MODULE_ID_VIRTUAL, cacheAllRouteRE, countSlashRE, dynamicRouteRE, nuxtCacheAllRouteRE, nuxtDynamicRouteRE, pathToNameRE, replaceDynamicRouteRE, replaceIndexRE } from './constants'\n\nimport type { ViteDevServer } from 'vite'\nimport type { ResolvedOptions } from './types'\n\nexport const debug = {\n  hmr: Debug('vite-plugin-pages:hmr'),\n  routeBlock: Debug('vite-plugin-pages:routeBlock'),\n  options: Debug('vite-plugin-pages:options'),\n  pages: Debug('vite-plugin-pages:pages'),\n  search: Debug('vite-plugin-pages:search'),\n  env: Debug('vite-plugin-pages:env'),\n  cache: Debug('vite-plugin-pages:cache'),\n  resolver: Debug('vite-plugin-pages:resolver'),\n}\n\nexport function extsToGlob(extensions: string[]) {\n  return extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0] || ''\n}\n\nexport function countSlash(value: string) {\n  return (value.match(countSlashRE) || []).length\n}\n\nfunction isPagesDir(path: string, options: ResolvedOptions) {\n  for (const page of options.dirs) {\n    const dirPath = slash(resolve(options.root, page.dir))\n    if (path.startsWith(dirPath)) return true\n  }\n  return false\n}\n\nexport function isTarget(path: string, options: ResolvedOptions) {\n  return isPagesDir(path, options) && options.extensionsRE.test(path)\n}\n\nexport function isDynamicRoute(routePath: string, nuxtStyle = false) {\n  return nuxtStyle\n    ? nuxtDynamicRouteRE.test(routePath)\n    : dynamicRouteRE.test(routePath)\n}\n\nexport function isCatchAllRoute(routePath: string, nuxtStyle = false) {\n  return nuxtStyle\n    ? nuxtCacheAllRouteRE.test(routePath)\n    : cacheAllRouteRE.test(routePath)\n}\n\nexport function resolveImportMode(\n  filepath: string,\n  options: ResolvedOptions,\n) {\n  const mode = options.importMode\n  if (typeof mode === 'function')\n    return mode(filepath, options)\n  return mode\n}\n\nexport function pathToName(filepath: string) {\n  return filepath.replace(pathToNameRE[0], '_').replace(pathToNameRE[1], '$')\n}\n\nexport function invalidatePagesModule(server: ViteDevServer) {\n  const { moduleGraph } = server\n  const module = moduleGraph.getModuleById(MODULE_ID_VIRTUAL)\n  if (module) {\n    moduleGraph.invalidateModule(module)\n    return module\n  }\n}\n\nexport function normalizeCase(str: string, caseSensitive: boolean) {\n  if (!caseSensitive) return str.toLocaleLowerCase()\n  return str\n}\n\nexport function normalizeName(name: string, isDynamic: boolean, nuxtStyle = false) {\n  if (!isDynamic) return name\n\n  return nuxtStyle\n    ? name.replace(nuxtDynamicRouteRE, '$1') || 'all'\n    : name.replace(replaceDynamicRouteRE, '$1')\n}\n\nexport function buildReactRoutePath(node: string, nuxtStyle = false): string | undefined {\n  const isDynamic = isDynamicRoute(node, nuxtStyle)\n  const isCatchAll = isCatchAllRoute(node, nuxtStyle)\n  const normalizedName = normalizeName(node, isDynamic, nuxtStyle)\n\n  if (isDynamic) {\n    if (isCatchAll)\n      return '*'\n\n    return `:${normalizedName}`\n  }\n\n  return `${normalizedName}`\n}\n\n// https://github.dev/remix-run/remix/blob/264e3f8884c5cafd8d06acc3e01153b376745b7c/packages/remix-dev/config/routesConvention.ts#L105\nexport function buildReactRemixRoutePath(node: string): string | undefined {\n  const escapeStart = '['\n  const escapeEnd = ']'\n  let result = ''\n  let rawSegmentBuffer = ''\n\n  let inEscapeSequence = 0\n  let skipSegment = false\n  for (let i = 0; i < node.length; i++) {\n    const char = node.charAt(i)\n    const lastChar = i > 0 ? node.charAt(i - 1) : undefined\n    const nextChar = i < node.length - 1 ? node.charAt(i + 1) : undefined\n\n    function isNewEscapeSequence() {\n      return (\n        !inEscapeSequence && char === escapeStart && lastChar !== escapeStart\n      )\n    }\n\n    function isCloseEscapeSequence() {\n      return inEscapeSequence && char === escapeEnd && nextChar !== escapeEnd\n    }\n\n    function isStartOfLayoutSegment() {\n      return char === '_' && nextChar === '_' && !rawSegmentBuffer\n    }\n\n    if (skipSegment) {\n      if (char === '/' || char === '.' || char === win32.sep)\n        skipSegment = false\n\n      continue\n    }\n\n    if (isNewEscapeSequence()) {\n      inEscapeSequence++\n      continue\n    }\n\n    if (isCloseEscapeSequence()) {\n      inEscapeSequence--\n      continue\n    }\n\n    if (inEscapeSequence) {\n      result += char\n      continue\n    }\n\n    if (char === '/' || char === win32.sep || char === '.') {\n      if (rawSegmentBuffer === 'index' && result.endsWith('index'))\n        result = result.replace(replaceIndexRE, '')\n      else result += '/'\n\n      rawSegmentBuffer = ''\n      continue\n    }\n\n    if (isStartOfLayoutSegment()) {\n      skipSegment = true\n      continue\n    }\n\n    rawSegmentBuffer += char\n\n    if (char === '$') {\n      result += typeof nextChar === 'undefined' ? '*' : ':'\n      continue\n    }\n\n    result += char\n  }\n\n  if (rawSegmentBuffer === 'index' && result.endsWith('index'))\n    result = result.replace(replaceIndexRE, '')\n\n  return result || undefined\n}\n","import {\n  pathToName,\n  resolveImportMode,\n} from './utils'\n\nimport type { ResolvedOptions } from './types'\n\nconst componentRE = /\"(?:component|element)\":(\"(.*?)\")/g\nconst hasFunctionRE = /\"(?:props|beforeEnter)\":(\"(.*?)\")/g\n\nconst multilineCommentsRE = /\\/\\*(.|[\\r\\n])*?\\*\\//gm\nconst singlelineCommentsRE = /\\/\\/.*/g\n\nfunction replaceFunction(_: any, value: any) {\n  if (value instanceof Function || typeof value === 'function') {\n    const fnBody = value.toString()\n      .replace(multilineCommentsRE, '')\n      .replace(singlelineCommentsRE, '')\n      .replace(/(\\t|\\n|\\r|\\s)/g, '')\n\n    // ES6 Arrow Function\n    if (fnBody.length < 8 || fnBody.substring(0, 8) !== 'function')\n      return `_NuFrRa_${fnBody}`\n\n    return fnBody\n  }\n\n  return value\n}\n\n/**\n * Creates a stringified Vue Router route definition.\n */\nexport function stringifyRoutes(\n  preparedRoutes: any[],\n  options: ResolvedOptions,\n) {\n  const imports: string[] = []\n\n  function componentReplacer(str: string, replaceStr: string, path: string) {\n    const mode = resolveImportMode(path, options)\n    if (mode === 'sync') {\n      const importName = pathToName(path)\n      const importStr = `import ${importName} from \"${path}\"`\n\n      // Only add import to array if it hasn't beed added before.\n      if (!imports.includes(importStr))\n        imports.push(importStr)\n\n      if (options.resolver === 'react')\n        return str.replace(replaceStr, `React.createElement(${importName})`)\n      else\n        return str.replace(replaceStr, importName)\n    } else {\n      if (options.resolver === 'react')\n        return str.replace(replaceStr, `React.createElement(React.lazy(() => import('${path}')))`)\n      else if (options.resolver === 'solid')\n        return str.replace(replaceStr, `Solid.lazy(() => import('${path}'))`)\n      else\n        return str.replace(replaceStr, `() => import('${path}')`)\n    }\n  }\n\n  function functionReplacer(str: string, replaceStr: string, content: string) {\n    if (content.startsWith('function'))\n      return str.replace(replaceStr, content)\n\n    if (content.startsWith('_NuFrRa_'))\n      return str.replace(replaceStr, content.slice(8))\n\n    return str\n  }\n\n  const stringRoutes = JSON\n    .stringify(preparedRoutes, replaceFunction)\n    .replace(componentRE, componentReplacer)\n    .replace(hasFunctionRE, functionReplacer)\n\n  return {\n    imports,\n    stringRoutes,\n  }\n}\n\nexport function generateClientCode(routes: any[], options: ResolvedOptions) {\n  const { imports, stringRoutes } = stringifyRoutes(routes, options)\n\n  if (options.resolver === 'react')\n    imports.push('import React from \\\"react\\\"')\n  if (options.resolver === 'solid')\n    imports.push('import * as Solid from \\\"solid-js\\\"')\n\n  return `${imports.join(';\\n')};\\n\\nconst routes = ${stringRoutes};\\n\\nexport default routes;`\n}\n","import {\n  buildReactRemixRoutePath,\n  buildReactRoutePath,\n  countSlash,\n  normalizeCase,\n} from '../utils'\nimport { generateClientCode } from '../stringify'\n\nimport type { Optional, ResolvedOptions } from '../types'\nimport type { PageContext } from '../context'\n\nexport interface ReactRouteBase {\n  caseSensitive?: boolean\n  children?: ReactRouteBase[]\n  element?: string\n  index?: boolean\n  path?: string\n  rawRoute: string\n}\n\nexport interface ReactRoute extends Omit<Optional<ReactRouteBase, 'rawRoute' | 'path'>, 'children'> {\n  children?: ReactRoute[]\n}\n\nfunction prepareRoutes(\n  routes: ReactRoute[],\n  options: ResolvedOptions,\n  parent?: ReactRoute,\n) {\n  for (const route of routes) {\n    if (parent)\n      route.path = route.path?.replace(/^\\//, '')\n\n    if (route.children)\n      route.children = prepareRoutes(route.children, options, route)\n\n    delete route.rawRoute\n\n    if (route.index)\n      delete route.path\n\n    Object.assign(route, options.extendRoute?.(route, parent) || {})\n  }\n\n  return routes\n}\n\nexport async function resolveReactRoutes(ctx: PageContext) {\n  const { routeStyle, caseSensitive } = ctx.options\n  const nuxtStyle = routeStyle === 'nuxt'\n\n  const pageRoutes = [...ctx.pageRouteMap.values()]\n    // sort routes for HMR\n    .sort((a, b) => countSlash(a.route) - countSlash(b.route))\n\n  const routes: ReactRouteBase[] = []\n\n  pageRoutes.forEach((page) => {\n    const pathNodes = page.route.split('/')\n    const element = page.path.replace(ctx.root, '')\n    let parentRoutes = routes\n\n    for (let i = 0; i < pathNodes.length; i++) {\n      const node = pathNodes[i]\n\n      const route: ReactRouteBase = {\n        caseSensitive,\n        path: '',\n        rawRoute: pathNodes.slice(0, i + 1).join('/'),\n      }\n\n      if (i === pathNodes.length - 1) route.element = element\n\n      const isIndexRoute = normalizeCase(node, caseSensitive).endsWith('index')\n\n      if (!route.path && isIndexRoute) {\n        route.index = true\n      } else if (!isIndexRoute) {\n        if (routeStyle === 'remix')\n          route.path = buildReactRemixRoutePath(node)\n        else\n          route.path = buildReactRoutePath(node, nuxtStyle)\n      }\n\n      // Check parent exits\n      const parent = parentRoutes.find((parent) => {\n        return pathNodes.slice(0, i).join('/') === parent.rawRoute\n      })\n\n      if (parent) {\n        // Make sure children exits in parent\n        parent.children = parent.children || []\n        // Append to parent's children\n        parentRoutes = parent.children\n      }\n\n      const exits = parentRoutes.some((parent) => {\n        return pathNodes.slice(0, i + 1).join('/') === parent.rawRoute\n      })\n      if (!exits)\n        parentRoutes.push(route)\n    }\n  })\n\n  // sort by dynamic routes\n  let finalRoutes = prepareRoutes(routes, ctx.options)\n\n  finalRoutes = (await ctx.options.onRoutesGenerated?.(finalRoutes)) || finalRoutes\n\n  let client = generateClientCode(finalRoutes, ctx.options)\n  client = (await ctx.options.onClientGenerated?.(client)) || client\n  return client\n}\n","import {\n  countSlash,\n  isCatchAllRoute,\n  isDynamicRoute,\n  normalizeCase,\n  normalizeName,\n} from '../utils'\nimport { generateClientCode } from '../stringify'\n\nimport type { CustomBlock, Optional } from '../types'\nimport type { PageContext } from '../context'\n\nexport interface VueRouteBase {\n  name: string\n  path: string\n  props?: boolean\n  component: string\n  children?: VueRouteBase[]\n  customBlock?: CustomBlock\n  rawRoute: string\n}\n\nexport interface VueRoute extends Omit<Optional<VueRouteBase, 'rawRoute' | 'name'>, 'children'> {\n  children?: VueRoute[]\n}\n\nfunction prepareRoutes(\n  ctx: PageContext,\n  routes: VueRoute[],\n  parent?: VueRoute,\n) {\n  for (const route of routes) {\n    if (route.name)\n      route.name = route.name.replace(/-index$/, '')\n\n    if (parent)\n      route.path = route.path?.replace(/^\\//, '')\n\n    if (route.children)\n      route.children = prepareRoutes(ctx, route.children, route)\n\n    if (route.children?.find(c => c.name === route.name))\n      delete route.name\n\n    route.props = true\n\n    delete route.rawRoute\n\n    if (route.customBlock) {\n      Object.assign(route, route.customBlock || {})\n      delete route.customBlock\n    }\n\n    Object.assign(route, ctx.options.extendRoute?.(route, parent) || {})\n  }\n\n  return routes\n}\n\nexport async function resolveVueRoutes(ctx: PageContext) {\n  const { routeStyle, caseSensitive } = ctx.options\n\n  const pageRoutes = [...ctx.pageRouteMap.values()]\n    // sort routes for HMR\n    .sort((a, b) => countSlash(a.route) - countSlash(b.route))\n\n  const routes: VueRouteBase[] = []\n\n  pageRoutes.forEach((page) => {\n    const pathNodes = page.route.split('/')\n\n    // add leading slash to component path if not already there\n    const component = page.path.replace(ctx.root, '')\n    const customBlock = ctx.customBlockMap.get(page.path)\n\n    const route: VueRouteBase = {\n      name: '',\n      path: '',\n      component,\n      customBlock,\n      rawRoute: page.route,\n    }\n\n    let parentRoutes = routes\n\n    for (let i = 0; i < pathNodes.length; i++) {\n      const node = pathNodes[i]\n      const nuxtStyle = routeStyle === 'nuxt'\n      const isDynamic = isDynamicRoute(node, nuxtStyle)\n      const isCatchAll = isCatchAllRoute(node, nuxtStyle)\n      const normalizedName = normalizeName(node, isDynamic, nuxtStyle)\n      const normalizedPath = normalizeCase(normalizedName, caseSensitive)\n\n      route.name += route.name ? `-${normalizedName}` : normalizedName\n\n      // Check parent exits\n      const parent = parentRoutes.find((parent) => {\n        return pathNodes.slice(0, i + 1).join('/') === parent.rawRoute\n      })\n\n      if (parent) {\n        // Make sure children exist in parent\n        parent.children = parent.children || []\n        // Append to parent's children\n        parentRoutes = parent.children\n        // Reset path\n        route.path = ''\n      } else if (normalizedPath === 'index') {\n        if (!route.path)\n          route.path = '/'\n      } else if (normalizedPath !== 'index') {\n        if (isDynamic) {\n          route.path += `/:${normalizedName}`\n          // Catch-all route\n          if (isCatchAll) {\n            if (i === 0)\n              // root cache all route include children\n              route.path += '(.*)*'\n            else\n              // nested cache all route not include children\n              route.path += '(.*)'\n          }\n        } else {\n          route.path += `/${normalizedPath}`\n        }\n      }\n    }\n\n    parentRoutes.push(route)\n  })\n\n  let finalRoutes = prepareRoutes(ctx, routes)\n\n  finalRoutes = (await ctx.options.onRoutesGenerated?.(finalRoutes)) || finalRoutes\n\n  let client = generateClientCode(finalRoutes, ctx.options)\n  client = (await ctx.options.onClientGenerated?.(client)) || client\n  return client\n}\n","import {\n  buildReactRemixRoutePath,\n  buildReactRoutePath,\n  countSlash,\n  normalizeCase,\n} from '../utils'\nimport { generateClientCode } from '../stringify'\n\nimport type { Optional, ResolvedOptions } from '../types'\nimport type { PageContext } from '../context'\n\nexport interface SolidRouteBase {\n  rawRoute: string\n  path: string\n  children?: SolidRouteBase[]\n  component?: string\n  element?: string\n}\n\nexport interface SolidRoute extends Omit<Optional<SolidRouteBase, 'rawRoute' | 'path'>, 'children'> {\n  children?: SolidRoute[]\n}\n\nfunction prepareRoutes(\n  options: ResolvedOptions,\n  routes: SolidRoute[],\n  parent?: SolidRoute,\n) {\n  for (const route of routes) {\n    if (parent)\n      route.path = route.path?.replace(/^\\//, '')\n\n    if (route.children)\n      route.children = prepareRoutes(options, route.children, route)\n\n    delete route.rawRoute\n\n    Object.assign(route, options.extendRoute?.(route, parent) || {})\n  }\n\n  return routes\n}\n\nexport async function resolveSolidRoutes(ctx: PageContext) {\n  const { routeStyle, caseSensitive } = ctx.options\n  const nuxtStyle = routeStyle === 'nuxt'\n\n  const pageRoutes = [...ctx.pageRouteMap.values()]\n    // sort routes for HMR\n    .sort((a, b) => countSlash(a.route) - countSlash(b.route))\n\n  const routes: SolidRouteBase[] = []\n\n  pageRoutes.forEach((page) => {\n    const pathNodes = page.route.split('/')\n\n    const component = page.path.replace(ctx.root, '')\n    const element = page.path.replace(ctx.root, '')\n\n    let parentRoutes = routes\n\n    for (let i = 0; i < pathNodes.length; i++) {\n      const node = pathNodes[i]\n      const normalizedPath = normalizeCase(node, caseSensitive)\n\n      const route: SolidRouteBase = {\n        path: '',\n        rawRoute: pathNodes.slice(0, i + 1).join('/'),\n      }\n\n      // Check parent exists\n      const parent = parentRoutes.find(parent =>\n        pathNodes.slice(0, i).join('/') === parent.rawRoute,\n      )\n\n      if (parent) {\n        // Make sure children exist in parent\n        parent.children = parent.children || []\n        // Append to parent's children\n        parentRoutes = parent.children\n      }\n\n      if (i === pathNodes.length - 1) {\n        route.element = element\n        route.component = component\n      }\n\n      if (normalizedPath === 'index') {\n        if (!route.path)\n          route.path = '/'\n      } else if (normalizedPath !== 'index') {\n        if (routeStyle === 'remix')\n          route.path = buildReactRemixRoutePath(node) || ''\n        else\n          route.path = buildReactRoutePath(node, nuxtStyle) || ''\n      }\n\n      const exist = parentRoutes.some((parent) => {\n        return pathNodes.slice(0, i + 1).join('/') === parent.rawRoute\n      })\n      if (!exist)\n        parentRoutes.push(route)\n    }\n  })\n\n  // sort by dynamic routes\n  let finalRoutes = prepareRoutes(ctx.options, routes)\n\n  finalRoutes = (await ctx.options.onRoutesGenerated?.(finalRoutes)) || finalRoutes\n\n  let client = generateClientCode(finalRoutes, ctx.options)\n  client = (await ctx.options.onClientGenerated?.(client)) || client\n  return client\n}\n","import fs from 'fs'\nimport JSON5 from 'json5'\nimport { parse as YAMLParser } from 'yaml'\n\nimport { importModule } from 'local-pkg'\n\nimport { debug } from './utils'\nimport type { SFCBlock, SFCDescriptor } from '@vue/compiler-sfc'\nimport type { CustomBlock, ResolvedOptions } from './types'\n\nexport async function parseSFC(code: string): Promise<SFCDescriptor> {\n  try {\n    const { parse } = await importModule('@vue/compiler-sfc') as typeof import('@vue/compiler-sfc')\n    return parse(code, {\n      pad: 'space',\n    }).descriptor\n  } catch {\n    throw new Error('[vite-plugin-pages] Vue3\\'s \"@vue/compiler-sfc\" is required.')\n  }\n}\n\nexport function parseCustomBlock(block: SFCBlock, filePath: string, options: ResolvedOptions): any {\n  const lang = block.lang ?? options.routeBlockLang\n\n  debug.routeBlock(`use ${lang} parser`)\n\n  if (lang === 'json5') {\n    try {\n      return JSON5.parse(block.content)\n    } catch (err: any) {\n      throw new Error(`Invalid JSON5 format of <${block.type}> content in ${filePath}\\n${err.message}`)\n    }\n  } else if (lang === 'json') {\n    try {\n      return JSON.parse(block.content)\n    } catch (err: any) {\n      throw new Error(`Invalid JSON format of <${block.type}> content in ${filePath}\\n${err.message}`)\n    }\n  } else if (lang === 'yaml' || lang === 'yml') {\n    try {\n      return YAMLParser(block.content)\n    } catch (err: any) {\n      throw new Error(`Invalid YAML format of <${block.type}> content in ${filePath}\\n${err.message}`)\n    }\n  }\n}\n\nexport async function getRouteBlock(path: string, options: ResolvedOptions) {\n  const content = fs.readFileSync(path, 'utf8')\n  const parsed = await parseSFC(content)\n\n  const blockStr = parsed.customBlocks.find(b => b.type === 'route')\n\n  if (!blockStr)\n    return\n\n  const result = parseCustomBlock(blockStr, path, options) as CustomBlock\n  return result\n}\n","import { MODULE_IDS, MODULE_ID_VIRTUAL, ROUTE_BLOCK_ID_VIRTUAL, routeBlockQueryRE } from './constants'\nimport { PageContext } from './context'\n\nimport type { UserOptions } from './types'\nimport type { Plugin } from 'vite'\n\nfunction pagesPlugin(userOptions: UserOptions = {}): Plugin {\n  let ctx: PageContext\n\n  return {\n    name: 'vite-plugin-pages',\n    enforce: 'pre',\n    async configResolved(config) {\n      // auto set resolver for react project\n      if (\n        !userOptions.resolver\n        && config.plugins.find(i => i.name.includes('vite:react'))\n      )\n        userOptions.resolver = 'react'\n\n      // TODO: auto set resolver for solid project\n      if (\n        !userOptions.resolver\n        && config.plugins.find(i => i.name.includes('solid'))\n      )\n        userOptions.resolver = 'solid'\n\n      ctx = new PageContext(userOptions, config.root)\n      ctx.setLogger(config.logger)\n      await ctx.searchGlob()\n    },\n    configureServer(server) {\n      ctx.setupViteServer(server)\n    },\n    resolveId(id) {\n      if (MODULE_IDS.includes(id))\n        return MODULE_ID_VIRTUAL\n\n      if (routeBlockQueryRE.test(id))\n        return ROUTE_BLOCK_ID_VIRTUAL\n\n      return null\n    },\n    async load(id) {\n      if (id === MODULE_ID_VIRTUAL)\n        return ctx.resolveRoutes()\n\n      if (id === ROUTE_BLOCK_ID_VIRTUAL) {\n        return {\n          code: 'export default {};',\n          map: null,\n        }\n      }\n\n      return null\n    },\n  }\n}\n\nexport * from './types'\nexport type {\n  VueRoute,\n  ReactRoute,\n  SolidRoute,\n} from './resolvers'\n\nexport { syncIndexResolver } from './options'\nexport { PageContext }\nexport default pagesPlugin\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,IAAM,aAAa;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEO,IAAM,oBAAoB;AAC1B,IAAM,yBAAyB;AAE/B,IAAM,oBAAoB;AAE1B,IAAM,iBAAiB;AACvB,IAAM,kBAAkB;AACxB,IAAM,wBAAwB;AAE9B,IAAM,qBAAqB;AAC3B,IAAM,sBAAsB;AAE5B,IAAM,eAAe;AAErB,IAAM,eAAe;AAAA,EAC1B;AAAA,EACA;AACF;AAEO,IAAM,iBAAiB;;;AC5B9B;AACA;;;ACMA,iBAAiB,OAAO;AACtB,UAAQ,SAAS,CAAC;AAClB,MAAI,MAAM,QAAQ,KAAK;AACrB,WAAO;AACT,SAAO,CAAC,KAAK;AACf;AAqGA,eAAe,KAAK;AAClB,SAAO,IAAI,QAAQ,OAAO,GAAG;AAC/B;AAkRA,iBAAW;AAAA,EACV;AAAA,EACA;AAAA,EAEA,YAAY,OAAO;AAClB,SAAK,QAAQ;AAAA,EACd;AACD;AA5YA;AA8YA,kBAAY;AAAA,EAKX,cAAc;AAJd;AACA;AACA;AAGC,SAAK,MAAM;AAAA,EACZ;AAAA,EAEA,QAAQ,OAAO;AACd,UAAM,OAAO,IAAI,KAAK,KAAK;AAE3B,QAAI,mBAAK,QAAO;AACf,yBAAK,OAAM,OAAO;AAClB,yBAAK,OAAQ;AAAA,IACd,OAAO;AACN,yBAAK,OAAQ;AACb,yBAAK,OAAQ;AAAA,IACd;AAEA,IAAK,AAAL,uBAAK,OAAL;AAAA,EACD;AAAA,EAEA,UAAU;AACT,UAAM,UAAU,mBAAK;AACrB,QAAI,CAAC,SAAS;AACb;AAAA,IACD;AAEA,uBAAK,OAAQ,mBAAK,OAAM;AACxB,IAAK,AAAL,uBAAK,OAAL;AACA,WAAO,QAAQ;AAAA,EAChB;AAAA,EAEA,QAAQ;AACP,uBAAK,OAAQ;AACb,uBAAK,OAAQ;AACb,uBAAK,OAAQ;AAAA,EACd;AAAA,MAEI,OAAO;AACV,WAAO,mBAAK;AAAA,EACb;AAAA,IAEG,OAAO,YAAY;AACrB,QAAI,UAAU,mBAAK;AAEnB,WAAO,SAAS;AACf,YAAM,QAAQ;AACd,gBAAU,QAAQ;AAAA,IACnB;AAAA,EACD;AACD;AAnDC;AACA;AACA;AAsHD,IAAM,OAAO,OAAO,QAAQ;;;ADpgB5B;;;AEHA;;;ACAA;AAEA;;;ACFA;AACA;AAOO,IAAM,QAAQ;AAAA,EACnB,KAAK,MAAM,uBAAuB;AAAA,EAClC,YAAY,MAAM,8BAA8B;AAAA,EAChD,SAAS,MAAM,2BAA2B;AAAA,EAC1C,OAAO,MAAM,yBAAyB;AAAA,EACtC,QAAQ,MAAM,0BAA0B;AAAA,EACxC,KAAK,MAAM,uBAAuB;AAAA,EAClC,OAAO,MAAM,yBAAyB;AAAA,EACtC,UAAU,MAAM,4BAA4B;AAC9C;AAEO,oBAAoB,YAAsB;AAC/C,SAAO,WAAW,SAAS,IAAI,IAAI,WAAW,KAAK,GAAG,OAAO,WAAW,MAAM;AAChF;AAEO,oBAAoB,OAAe;AACxC,SAAQ,OAAM,MAAM,YAAY,KAAK,CAAC,GAAG;AAC3C;AAEA,oBAAoB,MAAc,SAA0B;AAC1D,aAAW,QAAQ,QAAQ,MAAM;AAC/B,UAAM,UAAU,MAAM,QAAQ,QAAQ,MAAM,KAAK,GAAG,CAAC;AACrD,QAAI,KAAK,WAAW,OAAO;AAAG,aAAO;AAAA,EACvC;AACA,SAAO;AACT;AAEO,kBAAkB,MAAc,SAA0B;AAC/D,SAAO,WAAW,MAAM,OAAO,KAAK,QAAQ,aAAa,KAAK,IAAI;AACpE;AAEO,wBAAwB,WAAmB,YAAY,OAAO;AACnE,SAAO,YACH,mBAAmB,KAAK,SAAS,IACjC,eAAe,KAAK,SAAS;AACnC;AAEO,yBAAyB,WAAmB,YAAY,OAAO;AACpE,SAAO,YACH,oBAAoB,KAAK,SAAS,IAClC,gBAAgB,KAAK,SAAS;AACpC;AAEO,2BACL,UACA,SACA;AACA,QAAM,OAAO,QAAQ;AACrB,MAAI,OAAO,SAAS;AAClB,WAAO,KAAK,UAAU,OAAO;AAC/B,SAAO;AACT;AAEO,oBAAoB,UAAkB;AAC3C,SAAO,SAAS,QAAQ,aAAa,IAAI,GAAG,EAAE,QAAQ,aAAa,IAAI,GAAG;AAC5E;AAEO,+BAA+B,QAAuB;AAC3D,QAAM,EAAE,gBAAgB;AACxB,QAAM,SAAS,YAAY,cAAc,iBAAiB;AAC1D,MAAI,QAAQ;AACV,gBAAY,iBAAiB,MAAM;AACnC,WAAO;AAAA,EACT;AACF;AAEO,uBAAuB,KAAa,eAAwB;AACjE,MAAI,CAAC;AAAe,WAAO,IAAI,kBAAkB;AACjD,SAAO;AACT;AAEO,uBAAuB,MAAc,WAAoB,YAAY,OAAO;AACjF,MAAI,CAAC;AAAW,WAAO;AAEvB,SAAO,YACH,KAAK,QAAQ,oBAAoB,IAAI,KAAK,QAC1C,KAAK,QAAQ,uBAAuB,IAAI;AAC9C;AAEO,6BAA6B,MAAc,YAAY,OAA2B;AACvF,QAAM,YAAY,eAAe,MAAM,SAAS;AAChD,QAAM,aAAa,gBAAgB,MAAM,SAAS;AAClD,QAAM,iBAAiB,cAAc,MAAM,WAAW,SAAS;AAE/D,MAAI,WAAW;AACb,QAAI;AACF,aAAO;AAET,WAAO,IAAI;AAAA,EACb;AAEA,SAAO,GAAG;AACZ;AAGO,kCAAkC,MAAkC;AACzE,QAAM,cAAc;AACpB,QAAM,YAAY;AAClB,MAAI,SAAS;AACb,MAAI,mBAAmB;AAEvB,MAAI,mBAAmB;AACvB,MAAI,cAAc;AAClB,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAKpC,QAAS,sBAAT,WAA+B;AAC7B,aACE,CAAC,oBAAoB,SAAS,eAAe,aAAa;AAAA,IAE9D,GAES,wBAAT,WAAiC;AAC/B,aAAO,oBAAoB,SAAS,aAAa,aAAa;AAAA,IAChE,GAES,yBAAT,WAAkC;AAChC,aAAO,SAAS,OAAO,aAAa,OAAO,CAAC;AAAA,IAC9C;AAhBA,UAAM,OAAO,KAAK,OAAO,CAAC;AAC1B,UAAM,WAAW,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,IAAI;AAC9C,UAAM,WAAW,IAAI,KAAK,SAAS,IAAI,KAAK,OAAO,IAAI,CAAC,IAAI;AAgB5D,QAAI,aAAa;AACf,UAAI,SAAS,OAAO,SAAS,OAAO,SAAS,MAAM;AACjD,sBAAc;AAEhB;AAAA,IACF;AAEA,QAAI,oBAAoB,GAAG;AACzB;AACA;AAAA,IACF;AAEA,QAAI,sBAAsB,GAAG;AAC3B;AACA;AAAA,IACF;AAEA,QAAI,kBAAkB;AACpB,gBAAU;AACV;AAAA,IACF;AAEA,QAAI,SAAS,OAAO,SAAS,MAAM,OAAO,SAAS,KAAK;AACtD,UAAI,qBAAqB,WAAW,OAAO,SAAS,OAAO;AACzD,iBAAS,OAAO,QAAQ,gBAAgB,EAAE;AAAA;AACvC,kBAAU;AAEf,yBAAmB;AACnB;AAAA,IACF;AAEA,QAAI,uBAAuB,GAAG;AAC5B,oBAAc;AACd;AAAA,IACF;AAEA,wBAAoB;AAEpB,QAAI,SAAS,KAAK;AAChB,gBAAU,OAAO,aAAa,cAAc,MAAM;AAClD;AAAA,IACF;AAEA,cAAU;AAAA,EACZ;AAEA,MAAI,qBAAqB,WAAW,OAAO,SAAS,OAAO;AACzD,aAAS,OAAO,QAAQ,gBAAgB,EAAE;AAE5C,SAAO,UAAU;AACnB;;;AD7KA,mBAAmB,SAAmB;AACpC,SAAO,CAAC,gBAAgB,QAAQ,eAAe,GAAG,OAAO;AAC3D;AAKO,qBAAqB,aAA0B,MAAc,SAAkC;AACpG,QAAM,OAAO,GAAG,KAAK,MAAM,YAAY,GAAG,GAAG;AAAA,IAC3C,QAAQ,UAAU,OAAO;AAAA,IACzB,iBAAiB;AAAA,IACjB,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,KAAK;AAAA,EACP,CAAC;AAED,QAAM,WAAW,KAAK,IAAI,SAAQ,iCAC7B,cAD6B;AAAA,IAEhC;AAAA,EACF,EAAE;AAEF,SAAO;AACT;AAKO,sBAAsB,MAAc,SAAoC;AAC7E,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,MACE;AAEJ,QAAM,MAAM,WAAW,UAAU;AAEjC,QAAM,QAAQ,GAAG,KAAK,MAAM,KAAK,MAAM,QAAQ,KAAK,CAAC,GAAG;AAAA,IACtD,QAAQ,UAAU,OAAO;AAAA,IACzB,WAAW;AAAA,EACb,CAAC;AAED,SAAO;AACT;;;AD1CA,yBAAyB,MAA2B,MAAc,SAAmB;AACnF,SAAO,QAAQ,IAAI;AACnB,SAAO,KAAK,QAAQ,CAAC,QAAQ;AAC3B,UAAM,SAAS,OAAO,QAAQ,WAC1B,EAAE,KAAK,WAAW,GAAG,IACrB;AAEJ,WAAO,MAAM,MAAM,SAAQ,MAAM,OAAO,GAAG,CAAC,EAAE,QAAQ,GAAG,SAAS,EAAE;AACpE,WAAO,YAAY,OAAO,UAAU,QAAQ,OAAO,EAAE,EAAE,QAAQ,OAAO,EAAE;AAExE,WAAO,YAAY,QAAQ,MAAM,OAAO;AAAA,EAC1C,CAAC;AACH;AAEO,IAAM,oBAAwC,CAAC,UAAU,YAAY;AAC1E,aAAW,QAAQ,QAAQ,MAAM;AAC/B,QAAI,KAAK,cAAc,MAAM,SAAS,WAAW,IAAI,KAAK,WAAW;AACnE,aAAO;AAAA,EACX;AACA,SAAO;AACT;AAEA,IAAM,gBAAgB,CAAC,aAA0C;AAC/D,UAAQ;AAAA,SACH;AACH,aAAO,CAAC,OAAO,MAAM,IAAI;AAAA,SACtB;AAAA,SACA;AACH,aAAO,CAAC,OAAO,OAAO,MAAM,IAAI;AAAA;AAEhC,YAAM,IAAI,MAAM,yBAAyB,UAAU;AAAA;AAEvD;AAEO,wBAAwB,aAA0B,UAAoC;AAC3F,QAAM;AAAA,IACJ,OAAO,YAAY,YAAY,CAAC,WAAW;AAAA,IAC3C,iBAAiB;AAAA,IACjB,UAAU,CAAC;AAAA,IACX,gBAAgB;AAAA,IAChB,WAAW;AAAA,IACX,YAAY;AAAA,IACZ;AAAA,IACA;AAAA,IACA;AAAA,MACE;AAEJ,QAAM,OAAO,YAAY,MAAM,QAAQ,IAAI,CAAC;AAE5C,QAAM,aAAa,YAAY,cAAe,aAAY,oBAAoB;AAE9E,QAAM,aAAa,YAAY,cAAc,cAAc,QAAQ;AAEnE,QAAM,eAAe,IAAI,OAAO,OAAO,WAAW,KAAK,GAAG,KAAK;AAE/D,QAAM,eAAe,gBAAgB,MAAM,MAAM,OAAO;AAExD,QAAM,aAAa,YAAY,YAAY,SAAS,YAAY,cAAc;AAE9E,QAAM,kBAAmC;AAAA,IACvC,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AACT;;;AG3EA,IAAM,cAAc;AACpB,IAAM,gBAAgB;AAEtB,IAAM,sBAAsB;AAC5B,IAAM,uBAAuB;AAE7B,yBAAyB,GAAQ,OAAY;AAC3C,MAAI,iBAAiB,YAAY,OAAO,UAAU,YAAY;AAC5D,UAAM,SAAS,MAAM,SAAS,EAC3B,QAAQ,qBAAqB,EAAE,EAC/B,QAAQ,sBAAsB,EAAE,EAChC,QAAQ,kBAAkB,EAAE;AAG/B,QAAI,OAAO,SAAS,KAAK,OAAO,UAAU,GAAG,CAAC,MAAM;AAClD,aAAO,WAAW;AAEpB,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAKO,yBACL,gBACA,SACA;AACA,QAAM,UAAoB,CAAC;AAE3B,6BAA2B,KAAa,YAAoB,MAAc;AACxE,UAAM,OAAO,kBAAkB,MAAM,OAAO;AAC5C,QAAI,SAAS,QAAQ;AACnB,YAAM,aAAa,WAAW,IAAI;AAClC,YAAM,YAAY,UAAU,oBAAoB;AAGhD,UAAI,CAAC,QAAQ,SAAS,SAAS;AAC7B,gBAAQ,KAAK,SAAS;AAExB,UAAI,QAAQ,aAAa;AACvB,eAAO,IAAI,QAAQ,YAAY,uBAAuB,aAAa;AAAA;AAEnE,eAAO,IAAI,QAAQ,YAAY,UAAU;AAAA,IAC7C,OAAO;AACL,UAAI,QAAQ,aAAa;AACvB,eAAO,IAAI,QAAQ,YAAY,gDAAgD,UAAU;AAAA,eAClF,QAAQ,aAAa;AAC5B,eAAO,IAAI,QAAQ,YAAY,4BAA4B,SAAS;AAAA;AAEpE,eAAO,IAAI,QAAQ,YAAY,iBAAiB,QAAQ;AAAA,IAC5D;AAAA,EACF;AAEA,4BAA0B,KAAa,YAAoB,SAAiB;AAC1E,QAAI,QAAQ,WAAW,UAAU;AAC/B,aAAO,IAAI,QAAQ,YAAY,OAAO;AAExC,QAAI,QAAQ,WAAW,UAAU;AAC/B,aAAO,IAAI,QAAQ,YAAY,QAAQ,MAAM,CAAC,CAAC;AAEjD,WAAO;AAAA,EACT;AAEA,QAAM,eAAe,KAClB,UAAU,gBAAgB,eAAe,EACzC,QAAQ,aAAa,iBAAiB,EACtC,QAAQ,eAAe,gBAAgB;AAE1C,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEO,4BAA4B,QAAe,SAA0B;AAC1E,QAAM,EAAE,SAAS,iBAAiB,gBAAgB,QAAQ,OAAO;AAEjE,MAAI,QAAQ,aAAa;AACvB,YAAQ,KAAK,2BAA6B;AAC5C,MAAI,QAAQ,aAAa;AACvB,YAAQ,KAAK,mCAAqC;AAEpD,SAAO,GAAG,QAAQ,KAAK,KAAK;AAAA;AAAA,iBAAwB;AAAA;AAAA;AACtD;;;ACrEA,uBACE,QACA,SACA,QACA;AA5BF;AA6BE,aAAW,SAAS,QAAQ;AAC1B,QAAI;AACF,YAAM,OAAO,YAAM,SAAN,mBAAY,QAAQ,OAAO;AAE1C,QAAI,MAAM;AACR,YAAM,WAAW,cAAc,MAAM,UAAU,SAAS,KAAK;AAE/D,WAAO,MAAM;AAEb,QAAI,MAAM;AACR,aAAO,MAAM;AAEf,WAAO,OAAO,OAAO,eAAQ,gBAAR,iCAAsB,OAAO,YAAW,CAAC,CAAC;AAAA,EACjE;AAEA,SAAO;AACT;AAEA,kCAAyC,KAAkB;AA/C3D;AAgDE,QAAM,EAAE,YAAY,kBAAkB,IAAI;AAC1C,QAAM,YAAY,eAAe;AAEjC,QAAM,aAAa,CAAC,GAAG,IAAI,aAAa,OAAO,CAAC,EAE7C,KAAK,CAAC,GAAG,MAAM,WAAW,EAAE,KAAK,IAAI,WAAW,EAAE,KAAK,CAAC;AAE3D,QAAM,SAA2B,CAAC;AAElC,aAAW,QAAQ,CAAC,SAAS;AAC3B,UAAM,YAAY,KAAK,MAAM,MAAM,GAAG;AACtC,UAAM,UAAU,KAAK,KAAK,QAAQ,IAAI,MAAM,EAAE;AAC9C,QAAI,eAAe;AAEnB,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,YAAM,OAAO,UAAU;AAEvB,YAAM,QAAwB;AAAA,QAC5B;AAAA,QACA,MAAM;AAAA,QACN,UAAU,UAAU,MAAM,GAAG,IAAI,CAAC,EAAE,KAAK,GAAG;AAAA,MAC9C;AAEA,UAAI,MAAM,UAAU,SAAS;AAAG,cAAM,UAAU;AAEhD,YAAM,eAAe,cAAc,MAAM,aAAa,EAAE,SAAS,OAAO;AAExE,UAAI,CAAC,MAAM,QAAQ,cAAc;AAC/B,cAAM,QAAQ;AAAA,MAChB,WAAW,CAAC,cAAc;AACxB,YAAI,eAAe;AACjB,gBAAM,OAAO,yBAAyB,IAAI;AAAA;AAE1C,gBAAM,OAAO,oBAAoB,MAAM,SAAS;AAAA,MACpD;AAGA,YAAM,SAAS,aAAa,KAAK,CAAC,YAAW;AAC3C,eAAO,UAAU,MAAM,GAAG,CAAC,EAAE,KAAK,GAAG,MAAM,QAAO;AAAA,MACpD,CAAC;AAED,UAAI,QAAQ;AAEV,eAAO,WAAW,OAAO,YAAY,CAAC;AAEtC,uBAAe,OAAO;AAAA,MACxB;AAEA,YAAM,QAAQ,aAAa,KAAK,CAAC,YAAW;AAC1C,eAAO,UAAU,MAAM,GAAG,IAAI,CAAC,EAAE,KAAK,GAAG,MAAM,QAAO;AAAA,MACxD,CAAC;AACD,UAAI,CAAC;AACH,qBAAa,KAAK,KAAK;AAAA,IAC3B;AAAA,EACF,CAAC;AAGD,MAAI,cAAc,cAAc,QAAQ,IAAI,OAAO;AAEnD,gBAAe,MAAM,iBAAI,SAAQ,sBAAZ,4BAAgC,iBAAiB;AAEtE,MAAI,SAAS,mBAAmB,aAAa,IAAI,OAAO;AACxD,WAAU,MAAM,iBAAI,SAAQ,sBAAZ,4BAAgC,YAAY;AAC5D,SAAO;AACT;;;ACtFA,wBACE,KACA,QACA,QACA;AA9BF;AA+BE,aAAW,SAAS,QAAQ;AAC1B,QAAI,MAAM;AACR,YAAM,OAAO,MAAM,KAAK,QAAQ,WAAW,EAAE;AAE/C,QAAI;AACF,YAAM,OAAO,YAAM,SAAN,mBAAY,QAAQ,OAAO;AAE1C,QAAI,MAAM;AACR,YAAM,WAAW,eAAc,KAAK,MAAM,UAAU,KAAK;AAE3D,QAAI,YAAM,aAAN,mBAAgB,KAAK,OAAK,EAAE,SAAS,MAAM;AAC7C,aAAO,MAAM;AAEf,UAAM,QAAQ;AAEd,WAAO,MAAM;AAEb,QAAI,MAAM,aAAa;AACrB,aAAO,OAAO,OAAO,MAAM,eAAe,CAAC,CAAC;AAC5C,aAAO,MAAM;AAAA,IACf;AAEA,WAAO,OAAO,OAAO,iBAAI,SAAQ,gBAAZ,4BAA0B,OAAO,YAAW,CAAC,CAAC;AAAA,EACrE;AAEA,SAAO;AACT;AAEA,gCAAuC,KAAkB;AA3DzD;AA4DE,QAAM,EAAE,YAAY,kBAAkB,IAAI;AAE1C,QAAM,aAAa,CAAC,GAAG,IAAI,aAAa,OAAO,CAAC,EAE7C,KAAK,CAAC,GAAG,MAAM,WAAW,EAAE,KAAK,IAAI,WAAW,EAAE,KAAK,CAAC;AAE3D,QAAM,SAAyB,CAAC;AAEhC,aAAW,QAAQ,CAAC,SAAS;AAC3B,UAAM,YAAY,KAAK,MAAM,MAAM,GAAG;AAGtC,UAAM,YAAY,KAAK,KAAK,QAAQ,IAAI,MAAM,EAAE;AAChD,UAAM,cAAc,IAAI,eAAe,IAAI,KAAK,IAAI;AAEpD,UAAM,QAAsB;AAAA,MAC1B,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,UAAU,KAAK;AAAA,IACjB;AAEA,QAAI,eAAe;AAEnB,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,YAAM,OAAO,UAAU;AACvB,YAAM,YAAY,eAAe;AACjC,YAAM,YAAY,eAAe,MAAM,SAAS;AAChD,YAAM,aAAa,gBAAgB,MAAM,SAAS;AAClD,YAAM,iBAAiB,cAAc,MAAM,WAAW,SAAS;AAC/D,YAAM,iBAAiB,cAAc,gBAAgB,aAAa;AAElE,YAAM,QAAQ,MAAM,OAAO,IAAI,mBAAmB;AAGlD,YAAM,SAAS,aAAa,KAAK,CAAC,YAAW;AAC3C,eAAO,UAAU,MAAM,GAAG,IAAI,CAAC,EAAE,KAAK,GAAG,MAAM,QAAO;AAAA,MACxD,CAAC;AAED,UAAI,QAAQ;AAEV,eAAO,WAAW,OAAO,YAAY,CAAC;AAEtC,uBAAe,OAAO;AAEtB,cAAM,OAAO;AAAA,MACf,WAAW,mBAAmB,SAAS;AACrC,YAAI,CAAC,MAAM;AACT,gBAAM,OAAO;AAAA,MACjB,WAAW,mBAAmB,SAAS;AACrC,YAAI,WAAW;AACb,gBAAM,QAAQ,KAAK;AAEnB,cAAI,YAAY;AACd,gBAAI,MAAM;AAER,oBAAM,QAAQ;AAAA;AAGd,oBAAM,QAAQ;AAAA,UAClB;AAAA,QACF,OAAO;AACL,gBAAM,QAAQ,IAAI;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAEA,iBAAa,KAAK,KAAK;AAAA,EACzB,CAAC;AAED,MAAI,cAAc,eAAc,KAAK,MAAM;AAE3C,gBAAe,MAAM,iBAAI,SAAQ,sBAAZ,4BAAgC,iBAAiB;AAEtE,MAAI,SAAS,mBAAmB,aAAa,IAAI,OAAO;AACxD,WAAU,MAAM,iBAAI,SAAQ,sBAAZ,4BAAgC,YAAY;AAC5D,SAAO;AACT;;;ACnHA,wBACE,SACA,QACA,QACA;AA3BF;AA4BE,aAAW,SAAS,QAAQ;AAC1B,QAAI;AACF,YAAM,OAAO,YAAM,SAAN,mBAAY,QAAQ,OAAO;AAE1C,QAAI,MAAM;AACR,YAAM,WAAW,eAAc,SAAS,MAAM,UAAU,KAAK;AAE/D,WAAO,MAAM;AAEb,WAAO,OAAO,OAAO,eAAQ,gBAAR,iCAAsB,OAAO,YAAW,CAAC,CAAC;AAAA,EACjE;AAEA,SAAO;AACT;AAEA,kCAAyC,KAAkB;AA3C3D;AA4CE,QAAM,EAAE,YAAY,kBAAkB,IAAI;AAC1C,QAAM,YAAY,eAAe;AAEjC,QAAM,aAAa,CAAC,GAAG,IAAI,aAAa,OAAO,CAAC,EAE7C,KAAK,CAAC,GAAG,MAAM,WAAW,EAAE,KAAK,IAAI,WAAW,EAAE,KAAK,CAAC;AAE3D,QAAM,SAA2B,CAAC;AAElC,aAAW,QAAQ,CAAC,SAAS;AAC3B,UAAM,YAAY,KAAK,MAAM,MAAM,GAAG;AAEtC,UAAM,YAAY,KAAK,KAAK,QAAQ,IAAI,MAAM,EAAE;AAChD,UAAM,UAAU,KAAK,KAAK,QAAQ,IAAI,MAAM,EAAE;AAE9C,QAAI,eAAe;AAEnB,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,YAAM,OAAO,UAAU;AACvB,YAAM,iBAAiB,cAAc,MAAM,aAAa;AAExD,YAAM,QAAwB;AAAA,QAC5B,MAAM;AAAA,QACN,UAAU,UAAU,MAAM,GAAG,IAAI,CAAC,EAAE,KAAK,GAAG;AAAA,MAC9C;AAGA,YAAM,SAAS,aAAa,KAAK,aAC/B,UAAU,MAAM,GAAG,CAAC,EAAE,KAAK,GAAG,MAAM,QAAO,QAC7C;AAEA,UAAI,QAAQ;AAEV,eAAO,WAAW,OAAO,YAAY,CAAC;AAEtC,uBAAe,OAAO;AAAA,MACxB;AAEA,UAAI,MAAM,UAAU,SAAS,GAAG;AAC9B,cAAM,UAAU;AAChB,cAAM,YAAY;AAAA,MACpB;AAEA,UAAI,mBAAmB,SAAS;AAC9B,YAAI,CAAC,MAAM;AACT,gBAAM,OAAO;AAAA,MACjB,WAAW,mBAAmB,SAAS;AACrC,YAAI,eAAe;AACjB,gBAAM,OAAO,yBAAyB,IAAI,KAAK;AAAA;AAE/C,gBAAM,OAAO,oBAAoB,MAAM,SAAS,KAAK;AAAA,MACzD;AAEA,YAAM,QAAQ,aAAa,KAAK,CAAC,YAAW;AAC1C,eAAO,UAAU,MAAM,GAAG,IAAI,CAAC,EAAE,KAAK,GAAG,MAAM,QAAO;AAAA,MACxD,CAAC;AACD,UAAI,CAAC;AACH,qBAAa,KAAK,KAAK;AAAA,IAC3B;AAAA,EACF,CAAC;AAGD,MAAI,cAAc,eAAc,IAAI,SAAS,MAAM;AAEnD,gBAAe,MAAM,iBAAI,SAAQ,sBAAZ,4BAAgC,iBAAiB;AAEtE,MAAI,SAAS,mBAAmB,aAAa,IAAI,OAAO;AACxD,WAAU,MAAM,iBAAI,SAAQ,sBAAZ,4BAAgC,YAAY;AAC5D,SAAO;AACT;;;ACjHA;AACA;AACA;AAEA;AAMA,wBAA+B,MAAsC;AACnE,MAAI;AACF,UAAM,EAAE,UAAU,MAAM,aAAa,mBAAmB;AACxD,WAAO,MAAM,MAAM;AAAA,MACjB,KAAK;AAAA,IACP,CAAC,EAAE;AAAA,EACL,QAAE;AACA,UAAM,IAAI,MAAM,6DAA8D;AAAA,EAChF;AACF;AAEO,0BAA0B,OAAiB,UAAkB,SAA+B;AArBnG;AAsBE,QAAM,OAAO,YAAM,SAAN,YAAc,QAAQ;AAEnC,QAAM,WAAW,OAAO,aAAa;AAErC,MAAI,SAAS,SAAS;AACpB,QAAI;AACF,aAAO,MAAM,MAAM,MAAM,OAAO;AAAA,IAClC,SAAS,KAAP;AACA,YAAM,IAAI,MAAM,4BAA4B,MAAM,oBAAoB;AAAA,EAAa,IAAI,SAAS;AAAA,IAClG;AAAA,EACF,WAAW,SAAS,QAAQ;AAC1B,QAAI;AACF,aAAO,KAAK,MAAM,MAAM,OAAO;AAAA,IACjC,SAAS,KAAP;AACA,YAAM,IAAI,MAAM,2BAA2B,MAAM,oBAAoB;AAAA,EAAa,IAAI,SAAS;AAAA,IACjG;AAAA,EACF,WAAW,SAAS,UAAU,SAAS,OAAO;AAC5C,QAAI;AACF,aAAO,WAAW,MAAM,OAAO;AAAA,IACjC,SAAS,KAAP;AACA,YAAM,IAAI,MAAM,2BAA2B,MAAM,oBAAoB;AAAA,EAAa,IAAI,SAAS;AAAA,IACjG;AAAA,EACF;AACF;AAEA,6BAAoC,MAAc,SAA0B;AAC1E,QAAM,UAAU,GAAG,aAAa,MAAM,MAAM;AAC5C,QAAM,SAAS,MAAM,SAAS,OAAO;AAErC,QAAM,WAAW,OAAO,aAAa,KAAK,OAAK,EAAE,SAAS,OAAO;AAEjE,MAAI,CAAC;AACH;AAEF,QAAM,SAAS,iBAAiB,UAAU,MAAM,OAAO;AACvD,SAAO;AACT;;;ATrCO,wBAAkB;AAAA,EAUvB,YAAY,aAA0B,WAAmB,QAAQ,IAAI,GAAG;AARhE,yBAAgB,oBAAI,IAAuB;AAC3C,2BAA4C,oBAAI,IAAI;AAQ1D,SAAK,aAAa;AAClB,SAAK,OAAO,MAAM,QAAQ;AAC1B,UAAM,IAAI,QAAQ,KAAK,IAAI;AAC3B,SAAK,UAAU,eAAe,aAAa,KAAK,IAAI;AACpD,UAAM,QAAQ,KAAK,OAAO;AAAA,EAC5B;AAAA,EAEA,UAAU,QAAgB;AACxB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,gBAAgB,QAAuB;AACrC,QAAI,KAAK,YAAY;AACnB;AAEF,SAAK,UAAU;AACf,SAAK,aAAa,OAAO,OAAO;AAAA,EAClC;AAAA,EAEA,aAAa,SAAoB;AAC/B,YACG,GAAG,UAAU,CAAC,SAAS;AACtB,aAAO,MAAM,IAAI;AACjB,UAAI,CAAC,SAAS,MAAM,KAAK,OAAO;AAC9B;AACF,WAAK,WAAW,IAAI;AACpB,WAAK,SAAS;AAAA,IAChB,CAAC;AACH,YACG,GAAG,OAAO,OAAM,SAAS;AACxB,aAAO,MAAM,IAAI;AACjB,UAAI,CAAC,SAAS,MAAM,KAAK,OAAO;AAC9B;AACF,YAAM,OAAO,KAAK,QAAQ,KAAK,KAAK,OAAK,KAAK,WAAW,MAAM,SAAQ,KAAK,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC;AAC1F,YAAM,KAAK,QAAQ,MAAM,IAAI;AAC7B,WAAK,SAAS;AAAA,IAChB,CAAC;AAEH,YACG,GAAG,UAAU,OAAM,SAAS;AAC3B,aAAO,MAAM,IAAI;AACjB,UAAI,CAAC,SAAS,MAAM,KAAK,OAAO;AAC9B;AACF,YAAM,OAAO,KAAK,cAAc,IAAI,IAAI;AACxC,UAAI;AACF,aAAK,uBAAuB,IAAI;AAAA,IACpC,CAAC;AAAA,EACL;AAAA,QAEM,QAAQ,MAAyB,SAAsB;AAC3D,UAAM,MAAM,OAAO,IAAI;AACvB,eAAW,KAAK,QAAQ,IAAI,GAAG;AAC7B,YAAM,cAAc,MAAM,SAAQ,KAAK,MAAM,QAAQ,GAAG,CAAC;AACzD,YAAM,QAAQ,MAAM,MAAK,QAAQ,WAAW,EAAE,QAAQ,GAAG,gBAAgB,EAAE,EAAE,QAAQ,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC;AACrG,WAAK,cAAc,IAAI,GAAG;AAAA,QACxB,MAAM;AAAA,QACN;AAAA,MACF,CAAC;AACD,YAAM,KAAK,uBAAuB,CAAC;AAAA,IACrC;AAAA,EACF;AAAA,EAEA,WAAW,MAAyB;AAClC,UAAM,MAAM,UAAU,IAAI;AAC1B,YAAQ,IAAI,EAAE,QAAQ,CAAC,MAAM;AAC3B,WAAK,cAAc,OAAO,CAAC;AAC3B,WAAK,gBAAgB,OAAO,CAAC;AAAA,IAC/B,CAAC;AAAA,EACH;AAAA,QAEM,uBAAuB,MAAc;AAtG7C;AAuGI,QAAI,KAAK,QAAQ,aAAa;AAC5B;AAEF,UAAM,mBAAmB,KAAK,gBAAgB,IAAI,IAAI;AACtD,QAAI;AACJ,QAAI;AACF,oBAAc,MAAM,cAAc,MAAM,KAAK,OAAO;AAAA,IACtD,SAAS,OAAP;AAEA,iBAAK,WAAL,mBAAa,MAAM,OAAO,IAAI,uBAAuB,MAAM,SAAS;AACpE;AAAA,IACF;AACA,QAAI,CAAC,oBAAoB,CAAC;AACxB;AAEF,QAAI,CAAC,aAAa;AAChB,WAAK,gBAAgB,OAAO,IAAI;AAChC,YAAM,WAAW,cAAc,IAAI;AACnC;AAAA,IACF;AACA,QAAI,CAAC,oBAAoB,CAAC,UAAU,kBAAkB,WAAW,GAAG;AAClE,YAAM,WAAW,cAAc,MAAM,gBAAgB;AACrD,YAAM,WAAW,cAAc,MAAM,WAAW;AAChD,WAAK,gBAAgB,IAAI,MAAM,WAAW;AAC1C,WAAK,SAAS;AAAA,IAChB;AAAA,EACF;AAAA,EAEA,WAAW;AACT,QAAI,CAAC,KAAK;AACR;AAEF,0BAAsB,KAAK,OAAO;AAClC,UAAM,IAAI,yBAAyB;AACnC,SAAK,QAAQ,GAAG,KAAK;AAAA,MACnB,MAAM;AAAA,IACR,CAAC;AAAA,EACH;AAAA,QAEM,gBAAgB;AACpB,QAAI,KAAK,QAAQ,aAAa;AAC5B,aAAO,MAAM,iBAAiB,IAAI;AACpC,QAAI,KAAK,QAAQ,aAAa;AAC5B,aAAO,MAAM,mBAAmB,IAAI;AACtC,QAAI,KAAK,QAAQ,aAAa;AAC5B,aAAO,MAAM,mBAAmB,IAAI;AAAA,EACxC;AAAA,QAEM,aAAa;AACjB,UAAM,eAAe,KAAK,QAAQ,KAAK,IAAI,CAAC,SAAS;AACnD,YAAM,eAAe,MAAM,SAAQ,KAAK,QAAQ,MAAM,KAAK,GAAG,CAAC;AAC/D,YAAM,QAAQ,aAAa,cAAc,KAAK,OAAO;AACrD,YAAM,OAAO,KAAK,KAAK,KAAK;AAC5B,aAAO,iCACF,OADE;AAAA,QAEL,OAAO,MAAM,IAAI,UAAQ,MAAM,IAAI,CAAC;AAAA,MACtC;AAAA,IACF,CAAC;AAED,eAAW,QAAQ;AACjB,YAAM,KAAK,QAAQ,KAAK,OAAO,IAAI;AAErC,UAAM,MAAM,KAAK,YAAY;AAC7B,UAAM,MAAM,KAAK,cAAc;AAAA,EACjC;AAAA,MAEI,QAAQ;AACV,WAAO;AAAA,EACT;AAAA,MAEI,eAAe;AACjB,WAAO,KAAK;AAAA,EACd;AAAA,MAEI,iBAAiB;AACnB,WAAO,KAAK;AAAA,EACd;AACF;;;AU9KA,qBAAqB,cAA2B,CAAC,GAAW;AAC1D,MAAI;AAEJ,SAAO;AAAA,IACL,MAAM;AAAA,IACN,SAAS;AAAA,UACH,eAAe,QAAQ;AAE3B,UACE,CAAC,YAAY,YACV,OAAO,QAAQ,KAAK,OAAK,EAAE,KAAK,SAAS,YAAY,CAAC;AAEzD,oBAAY,WAAW;AAGzB,UACE,CAAC,YAAY,YACV,OAAO,QAAQ,KAAK,OAAK,EAAE,KAAK,SAAS,OAAO,CAAC;AAEpD,oBAAY,WAAW;AAEzB,YAAM,IAAI,YAAY,aAAa,OAAO,IAAI;AAC9C,UAAI,UAAU,OAAO,MAAM;AAC3B,YAAM,IAAI,WAAW;AAAA,IACvB;AAAA,IACA,gBAAgB,QAAQ;AACtB,UAAI,gBAAgB,MAAM;AAAA,IAC5B;AAAA,IACA,UAAU,IAAI;AACZ,UAAI,WAAW,SAAS,EAAE;AACxB,eAAO;AAET,UAAI,kBAAkB,KAAK,EAAE;AAC3B,eAAO;AAET,aAAO;AAAA,IACT;AAAA,UACM,KAAK,IAAI;AACb,UAAI,OAAO;AACT,eAAO,IAAI,cAAc;AAE3B,UAAI,OAAO,wBAAwB;AACjC,eAAO;AAAA,UACL,MAAM;AAAA,UACN,KAAK;AAAA,QACP;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAWA,IAAO,cAAQ;","names":[]}